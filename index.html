<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EPSMap</title>
    
    <link rel="stylesheet" href="media/bootstrap-v4.6.1/bootstrap.min.css">
    <link rel="stylesheet" href="media/fontawesome-4.7.0/font-awesome.min.css">
    <link rel="stylesheet" href="media/virtualselect-1.0.26/virtual-select.min.css">
    <link rel="stylesheet" href="media/tooltip-1.0.16/tooltip.min.css">
    <link rel="stylesheet" href="media/styles.css">
</head>
<body>
    <header>
        <div class="header-title">
            <h1>EPSMap</h1>
            <h2>Sistema de navegació intern pels edificis de la EPS</h2>
        </div>
    </header>
    <div class="content">
        <div class="main-title">
            <h3>Selecciona la teva destinació</h3>
        </div>
        <div>
            <div class="search-option-wrapper">
                <div style="display: flex;">
                    <input type="checkbox" style="margin-right: 5px;" class="" id="people" name="people"/>
                    <label class="toggle" for="people">People</label>
                </div>
                <div style="display: flex;">
                    <input type="checkbox" style="margin-right: 5px;" class="" id="space" name="space"/>
                    <label class="toggle" for="space">Space</label>
                </div>
            </div>
            <div id="vs-searcher"></div>
            <div id="path-instructions" class="d-none"></div>
        </div>
    </div>
    <div id="dark-background" class="d-none"></div>
    <div id="fullscreen-image" class="d-none"></div>
    <script src="media/jquery-3.6.0/jquery-3.6.0.min.js"></script>
    <script src="media/bootstrap-v4.6.1/bootstrap.bundle.min.js"></script>
    <script src="media/virtualselect-1.0.26/virtual-select.min.js"></script>
    <script src="media/tooltip-1.0.16/tooltip.min.js"></script>
    <!-- <script src="media/scripts.js"></script> -->
    <script>
        const VirtualSelect_Searcher = function(config){

            if(!config.main) throw new Error("Main HTML node to attach the searcher not given");
            if($(config.main).length == 0) throw new Error("The given HTML node is empty");
            if(!config.capture_point_id) throw new Error("Capture point ID for the search was not given");
            if(config.capture_point_id == NaN) throw new Error("Capture point ID must be a number");
            const capture_point_id = config.capture_point_id;
            let search_timeout = null;

            // If the variable starts with "$", that means it holds a jQuery object

            let $button = $("<button/>", { // Button to search
                    "class": "searcher-button btn btn-primary btn-sm",
                    "disabled": 1,
                    "type": "button"
                }).text("Search"),
                
                $vs = $("<div/>", { // Div where the vs-comp will be placed
                    "id": randomID(8)
                }),

                $wrapper = $(config.main).addClass("searcher-wrapper").append($vs, $("<div/>").append($button)), // Place everything inside the wrapper, the button is placed inside another div

                vs = VirtualSelect.init({ // Once everything is in the DOM initialize the vs-comp
                    ele: "#"+$vs.attr("id"),
                    search: true,
                    markSearchResults: true,
                    showSelectedOptionsFirst: true,
                    onServerSearch: function(value, virtualSelect){
                        clearTimeout(search_timeout);
                        search_timeout = setTimeout(() => {
                            searchValue(value).then(response => updateSelect(response, virtualSelect)).catch(jqXHR => console.error(jqXHR));
                        }, 200);
                    }
                });


            // Different checkboxes for different search values to include
            let checkbox_people = (config.people && config.people.checkbox) ? $(config.people.checkbox) : null,
                checkbox_spaces = (config.spaces && config.spaces.checkbox) ? $(config.spaces.checkbox) : null;
            
            // List with the checkboxes the user gave us
            const active_checkboxes = [];
            checkbox_people && active_checkboxes.push(checkbox_people);
            checkbox_spaces && active_checkboxes.push(checkbox_spaces);

            /**
             * Search a value in the database
             * @param {String} value Value to search
             * 
             * @returns {Promise} On resolve returns the list of places found, on reject returns the jqXHR error object
             */
            async function searchValue(value){
                return new Promise((resolve, reject) => {
                    const include_people = (checkbox_people && checkbox_people.is(":checked")) ? 1 : 0,
                          include_spaces = (checkbox_spaces && checkbox_spaces.is(":checked")) ? 1 : 0;
                    
                    if(!include_people && !include_spaces) resolve([]);
    
                    $.ajax({
                        type: "GET",
                        data: {
                            "text_search": value,
                            "limit": 50,
                            "people": include_people,
                            "space": include_spaces
                        },
                        url: "actions/search.php",
                        success: response => resolve(response),
                        error: jqXHR => reject(jqXHR)
                    })
                })
            }

            async function searchPathTo(destination_node_id){
                return new Promise((resolve, reject) => {
                    $.ajax({
                        type: "GET",
                        data: {
                            capture_point_id: capture_point_id,
                            destination_node_id: destination_node_id
                        },
                        url: "actions/get_path.php",
                        success: response => resolve(response),
                        error: jqXHR => reject(jqXHR)
                    })
                });
            }

            /**
             * Get the name to use when displaying a space to the user
             * 
             * @param {Object} space_obj The JSON object space
             * @param {Boolean} in_person Whether the space will be used inside a person's name or not
             * 
             * @returns {String} The value to use
             */
            function getSpaceName(space_obj, in_person=false){
                const space_types = {
                    1: "Aula",
                    2: "Bany",
                    3: "Despatx",
                    4: "Laboratori",
                    5: "Aula informàtica",
                    6: "Hivernacle",
                    7: "Auditori"
                };

                if(in_person) return space_obj.name;
                else {
                    return space_obj.name + " (" + (space_obj.alias ? space_obj.alias + ", " : "") + space_types[space_obj.space_type_id] + ")";
                }
            }

            /**
             * Get the name to use when displaying a person to the user
             * 
             * @param {Object} person_obj The JSON object person
             * 
             * @returns {String} The value to use
             */
            function getPersonName(person_obj){
                return person_obj.name + " (" + (person_obj.department.alias || person_obj.department.name) + ", " + getSpaceName(person_obj.space, true) + ")";
            }

    
            /**
             * Update the virtualSelect
             * 
             * @param {Array} new_values An array with the new values returned by the server
             * 
             * @returns {void}
             */
            function updateSelect(new_values){
                // The values for the VirtualSelect have a preappended random value to avoid problems when two differents objects point to the same final node id
                // The values need to be unique, and without the random value, they wouldn't be unique, you can get the actual ID with value.split("-")[1]
                let option_groups = [];
                if(checkbox_spaces && new_values.space && new_values.space.length > 0){
                    let options = {
                        "label": "Spaces",
                        "options": []
                    }
                    options.options.push(...new_values.space.map(elem => { 
                        return { 
                            // "label": elem.name, 
                            "label": getSpaceName(elem), 
                            "value": randomID(3)+"-"+elem.destination_zone.main_node 
                        } 
                    }))
                    option_groups.push(options);
                }
                
                if(checkbox_people && new_values.people && new_values.people.length > 0){
                    let options = {
                        "label": "People",
                        "options": []
                    }
                    options.options.push(...new_values.people.map(elem => { 
                        return { 
                            // "label": elem.name + " (" + (elem.department.alias || elem.department.name) + ", " + elem.space.name + ")",
                            "label": getPersonName(elem),
                            "value": randomID(3)+"-"+elem.main_node.id 
                        }
                    }))
                    option_groups.push(options);
                }
    
                vs.setServerOptions(option_groups);
            }

            /**
             * Generate a random string
             */
            function randomID(length) {
                let result           = '',
                    letters          = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',
                    numbers          = '0123456789',
                    characters       = letters+numbers,
                    charactersLength = characters.length;

                result += letters.charAt(Math.floor(Math.random() * letters.length)); // Force the first to be a letter, if the first is a number JS will throw an error

                for ( let i = 1; i < length; i++ ) {
                    result += characters.charAt(Math.floor(Math.random() * charactersLength));
                }

                return result;
            }
            
            // On change the status of any of the given checkboxes perform an empty search
            active_checkboxes.forEach(elem => {
                elem.on('change', event => { 
                    searchValue("").then(response => updateSelect(response, vs)).catch(jqXHR => console.error(jqXHR));
                });
            })
    
            // When a value is selected enable the button to search
            $vs.on('change', event => {
                if($vs.val() != "") $button.prop("disabled", 0);
                else $button.prop("disabled", 1);
            });

            $button.on('click', event => {
                const final_node_id = $vs.val().split("-")[1];
                console.log(final_node_id);
                searchPathTo(final_node_id).then(path => config.onSelectDestination(final_node_id, path.instructions, path.total_cost, path.initial_turn)).catch(jqXHR => console.error(jqXHR));
            });
        }



        const searchParams = (new URL(window.location.href)).searchParams;
        const capture_point_id = parseInt(searchParams.get("cp_id")) || 1;
        const language = searchParams.get("lang") || "es";


        VirtualSelect_Searcher({
            main: $("#vs-searcher"),
            people: {
                checkbox: $("input[type=checkbox][name=people]")
            },
            spaces: {
                checkbox: $("input[type=checkbox][name=space]")
            },
            capture_point_id: capture_point_id,
            language: "es",
            onSelectDestination: (destination, path, total_cost, initial_turn=null) => {
                let path_instructions = $("#path-instructions");
                path_instructions.removeClass("d-none");
                path_instructions.empty();
                if(initial_turn){
                    path_instructions.append($("<div/>", {
                            class: "instruction-wrapper"
                        }).append($("<div/>", { class: "instruction-text" }).text("Initial turn: " + initial_turn))
                    );
                }
                path.forEach(edge => {
                    const from_edge = edge.from;
                    const to_edge = edge.to;
                    const instruction_translation = edge.instruction_translation;
                    const has_image = edge.has_image;
                    const instruction_image = has_image ? $("<div/>", {
                        class: "instruction-image"
                    }).append($("<img/>", {
                        src: "actions/getInstructionImage.php?initial_edge_id="+from_edge.id+"&destination_edge_id="+to_edge.id
                    })) : null;

                    const instruction_text = $("<div/>", {
                        class: "instruction-text"
                    }).text(instruction_translation.text);

                    const move_forward_text = $("<div/>", {
                        class: "instruction-move"
                    }).text("Move forward " + from_edge.weight + " meters");
                    
                    path_instructions.append(move_forward_text);

                    
                    const instruction_wrapper = ($("<div/>", {
                        class: "instruction-wrapper" + (has_image ? " has-image" : "")
                    }).append(instruction_image, instruction_text)
                    );
                    
                    path_instructions.append(instruction_wrapper);
                });
                
                const move_forward_text = $("<div/>", {
                    class: "instruction-move"
                }).text("Move forward " + path[path.length -1].to.weight + " meters");

                path_instructions.append(move_forward_text);
                
            }
        });

        /**
         * Attach an event listener to open the images in full screen and close them
         * once the user tap anywhere else than the image
         */
        var FullScreenImage = function(){
            const close_image = () => {
                console.log(event);
                if(event.target != $("#fullscreen-image img")[0]){
                    console.log("HIDE");
                    $("body").removeClass("noscroll");
                    $("#dark-background").addClass("d-none");
                    $("#fullscreen-image").addClass("d-none");
                    $(document.body).off('click', close_image);
                }
            };

            $("#path-instructions").on("click", ".instruction-image img", event => {
                console.log(event.currentTarget);
                $("body").addClass("noscroll");
                $("#dark-background").removeClass("d-none");
                const fullscreen_image = $("#fullscreen-image");
                fullscreen_image.removeClass("d-none");
                fullscreen_image.empty();
                fullscreen_image.append($("<img/>", {
                    src: event.currentTarget.src
                }));

                setTimeout(() => {
                    $(document.body).on('click', close_image);
                }, 100);
            });
        }();
    </script>
</body>
</html>